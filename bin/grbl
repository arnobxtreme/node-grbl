#!/usr/bin/env node

var
  Hook          = require('hook.io').Hook,
  SerialPort    = require('serialport').SerialPort,
  parsers       = require('serialport').parsers,
  glob          = require('glob'),
  hook          = new Hook({
    name : 'grbl',
    debug : true,
    ignoreSTDIN : true
  });
  repl          = require('repl'),
  argv          = require('optimist').argv,
  colors        = require('colors'),
  vm            = require('vm'),
  EventEmitter  = require('events').EventEmitter,
  evalEmitter   = new EventEmitter(),
  gcodeQueue    = {},
  gcode         = global.G = global.gcode = function() {
    var args = [];
    Array.prototype.push.apply(args, arguments);
    console.log(('G' + args.join(' ')).bold.yellow);
    repl.repl.rli.history.pop();
    repl.repl.rli.emit('line', ('G' + args.join(' ')));
  },
  commands      = {
    record : (function() {
      var recorded = {};

      return function(name, fn) {

        if (!fn || name.replace(/\W'/) === '') {
          return (fn || name)(new Error('please provide a name: `record <name>`'));
        }

        commands.play = function(name, fn) {

          if (!recorded[name]) {
            fn(new Error("recording '" + name + "' was not found".bold.red));
          } else {
            recorded[name].forEach(function(command) {
              console.log(command.green);
              repl.repl.rli.emit('line', command + '\n');
            });
            fn();
          }
        }

        console.log('recording commands into "' + name.green + '"');
        repl.repl.prompt = "grbl:" + name + "> ";
        repl.repl.displayPrompt();
        recorded[name] = [];
        var recordCommands = function(data) {
          recorded[name].push(data.command);
        };
        evalEmitter.on('command', recordCommands);
        commands.stop = function(fn) {
          repl.repl.prompt = "grbl> ";
          delete commands['stop'];
          recorded[name].pop(); // clean the stop command off of the command list
          evalEmitter.removeListener('command', recordCommands);
          fn(null, 'done recording');
        };
      }
    })(),
  };

var connected = false, currentSP;

var disconnected = function(reconnectFn) {
  process.stdout.write('\nnot connected'.bold.red);
  connected = false;
  (function attemptReconnect() {

    process.stdout.write('.'.red);
    findSerialPort({}, function(err, sp) {
      if (err) {

        setTimeout(function() {
          attemptReconnect(reconnectFn);
        }, 200);
      } else {
        connected = true;
        console.log('\nconnected!'.bold.green + '\n');
        currentSP = sp;
        reconnectFn();
      }
    });
  })();
};


module.exports = function() {
  var reconnecting = false;
  findSerialPort({}, function initialize(err, sp) {

    if (err) {
      reconnecting = true;
      disconnected(initialize)
      return;
    }

    // avoid double 'connected' messages
    if (!reconnecting) {
      console.log('connected!'.bold.green);
    }
    ran = true;

    if (!currentSP) {
      currentSP = sp;
    }

    currentSP.on('data', function grblHeader(data) {
      if (data.indexOf("'$' to dump current settings") > -1) {

        currentSP.removeListener('data', grblHeader);

        repl.start('grbl> ', null, function evil(cmd, r, name, fn) {
          if (currentSP) {
            strippedCmd = cmd.replace(/^\(|\)$/g, '');

            evalEmitter.emit('command', {
              rawCommand  : cmd,
              command     : strippedCmd
            });

            // guard against noops
            if (strippedCmd.replace(/\W/,'') === "") {
              return;
            }

            var commandParts = strippedCmd.replace('\n', '').split(' ');
            var command = commandParts[0].replace(/\W/,'');

            // Handle custom commands
            if (commands[command]) {
              var args = commandParts.slice(1);
              args.push(function(err, text) {
                if (err) {
                  console.log((err.message || err).bold.red);
                } else {
                  console.log(text);
                }
                repl.repl.displayPrompt();
              });
              commands[command].apply(repl, args || []);

            // Handle GCODE
            } else if (strippedCmd.match(/^[a-z][0-9][0-9]?/i) || strippedCmd.replace(/[ \n]*/g, '').match(/^[\?\$]/)) {
              repl.repl.outputStream.write('\n');
              currentSP.write(strippedCmd);

              // TODO: transmit to hookio

            // Handle javascript
            } else {
              var err, result;
              try {
                result = vm.runInThisContext(cmd, 'grbl repl');
              } catch (e) {
                err = e;
              }
              fn(err, result);
            }
          }
        }, true, true);
      }
    });
  });
};

var findSerialPort = module.exports.findSerialPort = function(options, fn) {
  var found = false;
  // Find serialport
  glob('/dev/tty.usb*', function(e, matches) {
    matches.forEach(function(v) {
      if (!found) {
        // TODO: actually query the port for 'grbl' string
        // TODO: consider the problems this may cause if connecting to a running
        //       machine.
        var sp = new SerialPort(v, {
            parser: parsers.readline("\n")
        });

        sp.on('error', function(error) {
          console.log('here');
        });

        sp.on('end', function() {
          disconnected(function() {})
        });

        sp.on('data', function(data) {
          if (!data) { return; }
          var matches = data.match(/(error|ok|\$)/i);
          if (matches) {
            var color;
            switch (matches[0]) {
              case 'ok':
                color = 'green';
              break;

              case 'error':
                color = 'red';
              break;

              case '$':
                color = 'yellow';
              break;
            }
            console.log(data[color] || data);

            if (matches[0] === 'ok' || matches[0] === 'error' || data.substring(0,3) === "'$'") {
              console.log('');
              if (repl.repl) {
                repl.repl.displayPrompt();
              }
            }

          } else {
            console.log(data);
          }
        });

        found = true;
        fn(null, sp);
      }
    });

    if (!found) {
      fn(new Error('not found'));
    }
  });
};

/*
  incoming gcode is expected to be in the form:

  {
    "name" : "cube.gcode",
    "gcode" : [
      "G1 X0",
      "G1 X100 Z-90"
    ]
  }

*/

hook.on('*::gcode', function(data) {
  // We do two things here:
  // 1) add this gcode into a queue
  // 2) if a repl has already been started, kick off the process

  gcodeQueue[data.name] = data.gcode;

  // Repl has been started and we are currently connected to the
  // arduino
  if (repl.repl && currentSP) {
    (function next(i) {
      if (i>=data.gcode.length) {
        hook.emit('progress', { current : i, total : i });

        // print done and return to prompt
        console.log('DONE!'.yellow);
        repl.repl.displayPrompt();
        return;
      }
      var line = data.gcode[i];

      console.log(line.bold.green);
      currentSP.on('data', function waitForOk(response) {
        if (response.indexOf('ok') > -1) {
          currentSP.removeListener('data', waitForOk);

          hook.emit('progress', {
            current : i,
            total : data.gcode.length
          });

          next(i+1);
        }
      });

      currentSP.write(line + "\n");

    })(0);
    data.gcode.forEach(function(line) {

    });
  }
});

hook.start()

module.exports();